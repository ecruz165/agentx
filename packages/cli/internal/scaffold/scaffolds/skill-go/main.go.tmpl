// {{.Name}} — AgentX Skill (Go)
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

const (
	skillTopic  = "{{.Topic}}"
	skillVendor = "{{.Vendor}}"
	skillName   = "{{.Name}}"
)

func skillPath() string {
	{{- if .Vendor}}
	return filepath.Join(skillTopic, skillVendor, skillName)
	{{- else}}
	return filepath.Join(skillTopic, skillName)
	{{- end}}
}

func userdataRoot() string {
	if v := os.Getenv("AGENTX_USERDATA"); v != "" {
		return v
	}
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".agentx", "userdata")
}

// Registry — one folder with everything about this skill
type Registry struct {
	Root      string
	Tokens    string
	Config    string
	State     string
	Output    string
	Templates string
	// Shared
	EnvDefault string
	EnvVendor  string
	Profile    string
	Prefs      string
}

func newRegistry() Registry {
	root := userdataRoot()
	sp := skillPath()
	return Registry{
		Root:       filepath.Join(root, "skills", sp),
		Tokens:     filepath.Join(root, "skills", sp, "tokens.env"),
		Config:     filepath.Join(root, "skills", sp, "config.yaml"),
		State:      filepath.Join(root, "skills", sp, "state"),
		Output:     filepath.Join(root, "skills", sp, "output"),
		Templates:  filepath.Join(root, "skills", sp, "templates"),
		EnvDefault: filepath.Join(root, "env", "default.env"),
		EnvVendor:  filepath.Join(root, "env", skillVendor+".env"),
		Profile:    filepath.Join(root, "profiles", "active"),
		Prefs:      filepath.Join(root, "preferences.yaml"),
	}
}

func (r Registry) SaveOutput(data interface{}) error {
	os.MkdirAll(r.Output, 0755)
	payload, _ := json.MarshalIndent(data, "", "  ")
	os.WriteFile(filepath.Join(r.Output, "latest.json"), payload, 0644)
	ts := time.Now().Format("2006-01-02T15-04-05")
	return os.WriteFile(filepath.Join(r.Output, ts+".json"), payload, 0644)
}

func (r Registry) LoadTemplate(name string) (string, error) {
	data, err := os.ReadFile(filepath.Join(r.Templates, name))
	return string(data), err
}

func main() {
	reg := newRegistry()

	// TODO: Implement your skill logic here.
	//
	// Access everything through the registry:
	//   reg.Tokens     — path to tokens.env
	//   reg.Config     — path to config.yaml
	//   reg.State      — path to state/ directory
	//   reg.Output     — path to output/ directory
	//   reg.Templates  — path to templates/ directory

	result := map[string]interface{}{
		"timestamp": time.Now().Format(time.RFC3339),
		"skill":     skillName,
		"status":    "ok",
		"data": map[string]interface{}{
			"message": fmt.Sprintf("Hello from %s", skillName),
		},
	}

	if err := reg.SaveOutput(result); err != nil {
		fmt.Fprintf(os.Stderr, "Error saving output: %v\n", err)
		os.Exit(1)
	}

	output, _ := json.MarshalIndent(result, "", "  ")
	fmt.Println(string(output))
}
